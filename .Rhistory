creatr("Snake2.0")
library("devtools")
create("Snake2.0")
create("Snake2.0")
create("Snake2.0")
setwd("./Snake2.0")
document()
document()
if(!require(roxygen2)) install.packages("roxygen2")
roxygenize("Snake1.0") #运行完后会自动生成NAMESPACE文件与man文件夹
setwd("..")
setwd("~/Documents")
roxygenize("Snake1.0") #运行完后会自动生成NAMESPACE文件与man文件夹
roxygenize("Snake1.0") #运行完后会自动生成NAMESPACE文件与man文件夹
library(roxygen2)
roxygenize("Snake1.0") #运行完后会自动生成NAMESPACE文件与man文件夹
create("Snake1.0")
roxygenize("Snake1.0") #运行完后会自动生成NAMESPACE文件与man文件夹
install.packages("rstudioapi")
install.packages("rstudioapi")
library(usethis)
usethis::create_package("~/Documents/Snake1.1")
usethis::create_package("~/Documents/Snake1.1")
usethis::create_package("~/Documents/Snake1.1")
#' Snake1.0 function
#'
#' This function allows you to calculate the day based on date.
#' The formula used in the function is kim Larsson calculation formula.
#'
#' @keywords Snake1.0
#' @export
#' @examples
#' run()
#'
library(beepr)  # 导入包
# 初始化环境变量
init<-function(){
e<<-new.env()
e$stage<-0 #场景
e$width<-e$height<-20  #切分格子
e$step<-1/e$width #步长
e$m<-matrix(rep(0,e$width*e$height),nrow=e$width)  #点矩阵
e$dir<-e$lastd<-'up' # 移动方向
e$head<-c(2,2) #初始蛇头
e$lastx<-e$lasty<-2 # 初始化蛇头上一个点
e$tail<-data.frame(x=c(),y=c())#初始蛇尾
e$col_bla<-1  # 定义障碍物颜色
e$col_furit<-2 # 水果颜色
e$col_head<-4 # 蛇头颜色
e$col_tail<-8 # 蛇尾颜色
e$col_path<-0 # 路颜色
e$eat_num<-0 # 定义连续吃果子次数
e$bla<-c(10, 10)  # 初始化黑色障碍物的位置
e$bla_lastx<-e$bla_lasty<-10  # 初始化黑色位置
e$bla_A=1  # 控制方向
e$bla_B=10
}
# 获得矩阵的索引值
index<-function(col) which(e$m==col)
# 游戏中
stage1<-function(){
e$stage<-1
# 随机的水果点
furit<-function(){
if(length(index(e$col_furit))<=0){ #不存在水果
idx<-sample(index(e$col_path),1)
fx<-ifelse(idx%%e$width==0,10,idx%%e$width)
fy<-ceiling(idx/e$height)
e$m[fx,fy]<-e$col_furit
print(paste("furit idx",idx))
print(paste("furit axis:",fx,fy))
}
}
bla<-function(){
e$bla_lastx<-e$bla[1]  # 记录障碍物原来位置
e$bla_lasty<-e$bla[2]
e$bla[1]<-e$bla[1]-e$bla_A  # 移动
e$bla[2]<-e$bla_B
if(e$m[e$bla[1], e$bla[2]] ==e$col_furit){
e$bla[1] = e$bla[1] -1
}  # 判断是否碰到果子
if(e$bla[1] == 1 | e$bla[1] == 20) {
e$bla_A=e$bla_A * -1  # 朝着反方向
}
if(e$bla[2] == 10 ) {
e$bla_B=e$bla_B  #
}
}
# 检查失败
fail<-function(){
# head出边界
if(length(which(e$head < 1))>0 | length(which(e$head > e$width))>0){
print("game over: Out of ledge.")
keydown('q')
return(TRUE)
}
# head碰到tail
if(e$m[e$head[1],e$head[2]]==e$col_tail){
print("game over: head hit tail")
keydown('q')
beep(3)
return(TRUE)
}
if(e$m[e$bla[1], e$bla[2]] == e$col_tail){
print("game over: head hit black")
keydown('q')
beep(3)
return(TRUE)
}
if(e$head[1] == e$bla[1] & e$head[2]==e$bla[2]){  # 碰到黑色障碍物失败
print("game over: head hit black")
keydown('q')
beep(3)
return(TRUE)
}
if(nrow(e$tail)>0){
}
return(FALSE)
}
# snake head
head<-function(){
e$lastx<-e$head[1]
e$lasty<-e$head[2]
# 方向操作
if(e$dir=='up') e$head[2]<-e$head[2]+1
if(e$dir=='down') e$head[2]<-e$head[2]-1
if(e$dir=='left') e$head[1]<-e$head[1]-1
if(e$dir=='right') e$head[1]<-e$head[1]+1
}
# snake body
body<-function(){
e$m[e$lastx,e$lasty]<-0
e$m[e$bla_lastx, e$bla_lasty]<-0
e$m[e$bla[1],e$bla[2]]<-e$col_bla
e$m[e$head[1],e$head[2]]<-e$col_head
print(data.frame(x=e$lastx,y=e$lasty))
if(e$eat_num == 3){ # 连续吃三次果子
e$tail<-rbind(e$tail,data.frame(x=e$lastx,y=e$lasty))  # 矩阵合并,增加节数
e$eat_num<-0  # 重置吃果子数
}
if(length(index(e$col_furit))<=0){ #不存在水果
e$tail<-rbind(e$tail,data.frame(x=e$lastx,y=e$lasty))  # 矩阵合并
beep(5)  # 播放声音
e$eat_num<-e$eat_num+1
}
if(nrow(e$tail)>0) { #如果有尾巴
e$tail<-rbind(e$tail,data.frame(x=e$lastx,y=e$lasty))
e$m[e$tail[1,]$x,e$tail[1,]$y]<-e$col_path
e$tail<-e$tail[-1,]
e$m[e$lastx,e$lasty]<-e$col_tail
}
print(paste("snake idx",index(e$col_head)))
print(paste("snake axis:",e$head[1],e$head[2]))
}
# 画布背景
drawTable<-function(){
plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
}
# 根据矩阵画数据
drawMatrix<-function(){
idx<-which(e$m>0)
px<- (ifelse(idx%%e$width==0,e$width,idx%%e$width)-1)/e$width+e$step/2
py<- (ceiling(idx/e$height)-1)/e$height+e$step/2
pxy<-data.frame(x=px,y=py,col=e$m[idx])
points(pxy$x,pxy$y,col=pxy$col,pch=15,cex=4.4)
text(0.5,0.8,label=paste("你的得分",nrow(e$tail)),cex=2,col=2)
# 添加得分，使得分在画面中实时显示
}
furit()
bla()
head()
if(!fail()){
body()
drawTable()
drawMatrix()
}
}
# 开机画图
stage0<-function(){
e$stage<-0
plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
text(0.5,0.7,label="Snake Game",cex=5)
text(0.5,0.4,label="Any keyboard to start",cex=2,col=4)
text(0.5,0.3,label="Up,Down,Left,Rigth to control direction",cex=2,col=2)
text(0.2,0.05,label="Author:DanZhang",cex=1)
text(0.5,0.05,label="http://blog.fens.me",cex=1)
text(0.5,0.1,label="cai-3198911509",cex=1)
}
# 结束画图
stage2<-function(){
e$stage<-2
plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
text(0.5,0.7,label="Game Over",cex=5)
text(0.5,0.4,label="Space to restart, q to quit.",cex=2,col=4)
text(0.5,0.3,label=paste("Congratulations! You have eat",nrow(e$tail),"fruits!"),cex=2,col=2)
text(0.2,0.05,label="Author:DanZhang",cex=1)
text(0.5,0.05,label="http://blog.fens.me",cex=1)
text(0.5,0.1,label="cai-3198911509",cex=1)
}
# 暂停画面
stage3<-function() {
e$stage<-3
plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
text(0.5,0.7,label="已暂停",cex=5)
text(0.5,0.4,label="按q退出，按p继续",cex=2,col=4)
text(0.5,0.3,label=paste("Congratulations! You have eat",nrow(e$tail),"fruits!"),cex=2,col=2)
text(0.2,0.05,label="Author:DanZhang",cex=1)
text(0.5,0.05,label="http://blog.fens.me",cex=1)
text(0.5,0.1,label="cai-3198911509",cex=1)
}
# 键盘事件
keydown<-function(K){
print(paste("keydown:",K,",stage:",e$stage));
if(e$stage==3) {
if(K == "q"){
stage2()  # 按下q键结束
}
if(K == "p"){
stage1()  # 按下p继续游戏
}
return(NULL)
}
if(e$stage==0){ # 开机画面
init()
stage1()
return(NULL)
}
if(e$stage==2){ # 结束画面
if(K=="q") q()
else if(K==' ') stage0()
return(NULL)
}
if(e$stage==1){ # 在游戏进行中
if(K == "q") {
stage2() # 如果按下q键就会结束
}
if (K == "p") {
stage3()  # 如果按下p，则进入暂停画面
} else {
if(tolower(K) %in% c("up","down","left","right")){
e$lastd<-e$dir
e$dir<-tolower(K)
stage1()
}
}
}
return(NULL)
}
#######################################
# RUN
#######################################
run<-function(){
X11()
par(mai=rep(0,4),oma=rep(0,4))
e<<-new.env()
stage0()
# 注册事件
getGraphicsEvent(prompt="Snake Game",onKeybd=keydown)
}
X11()
run()
usethis::use_r("Snake_run")
#' Snake1.0 function
#'
#' This function allows you to calculate the day based on date.
#' The formula used in the function is kim Larsson calculation formula.
#'
#' @keywords Snake1.0
#' @export
#' @examples
#' run()
#'
library(beepr)  # 导入包
# 初始化环境变量
Snake_run<-function(){
init<-function(){
e<<-new.env()
e$stage<-0 #场景
e$width<-e$height<-20  #切分格子
e$step<-1/e$width #步长
e$m<-matrix(rep(0,e$width*e$height),nrow=e$width)  #点矩阵
e$dir<-e$lastd<-'up' # 移动方向
e$head<-c(2,2) #初始蛇头
e$lastx<-e$lasty<-2 # 初始化蛇头上一个点
e$tail<-data.frame(x=c(),y=c())#初始蛇尾
e$col_bla<-1  # 定义障碍物颜色
e$col_furit<-2 # 水果颜色
e$col_head<-4 # 蛇头颜色
e$col_tail<-8 # 蛇尾颜色
e$col_path<-0 # 路颜色
e$eat_num<-0 # 定义连续吃果子次数
e$bla<-c(10, 10)  # 初始化黑色障碍物的位置
e$bla_lastx<-e$bla_lasty<-10  # 初始化黑色位置
e$bla_A=1  # 控制方向
e$bla_B=10
}
# 获得矩阵的索引值
index<-function(col) which(e$m==col)
# 游戏中
stage1<-function(){
e$stage<-1
# 随机的水果点
furit<-function(){
if(length(index(e$col_furit))<=0){ #不存在水果
idx<-sample(index(e$col_path),1)
fx<-ifelse(idx%%e$width==0,10,idx%%e$width)
fy<-ceiling(idx/e$height)
e$m[fx,fy]<-e$col_furit
print(paste("furit idx",idx))
print(paste("furit axis:",fx,fy))
}
}
bla<-function(){
e$bla_lastx<-e$bla[1]  # 记录障碍物原来位置
e$bla_lasty<-e$bla[2]
e$bla[1]<-e$bla[1]-e$bla_A  # 移动
e$bla[2]<-e$bla_B
if(e$m[e$bla[1], e$bla[2]] ==e$col_furit){
e$bla[1] = e$bla[1] -1
}  # 判断是否碰到果子
if(e$bla[1] == 1 | e$bla[1] == 20) {
e$bla_A=e$bla_A * -1  # 朝着反方向
}
if(e$bla[2] == 10 ) {
e$bla_B=e$bla_B  #
}
}
# 检查失败
fail<-function(){
# head出边界
if(length(which(e$head < 1))>0 | length(which(e$head > e$width))>0){
print("game over: Out of ledge.")
keydown('q')
return(TRUE)
}
# head碰到tail
if(e$m[e$head[1],e$head[2]]==e$col_tail){
print("game over: head hit tail")
keydown('q')
beep(3)
return(TRUE)
}
if(e$m[e$bla[1], e$bla[2]] == e$col_tail){
print("game over: head hit black")
keydown('q')
beep(3)
return(TRUE)
}
if(e$head[1] == e$bla[1] & e$head[2]==e$bla[2]){  # 碰到黑色障碍物失败
print("game over: head hit black")
keydown('q')
beep(3)
return(TRUE)
}
if(nrow(e$tail)>0){
}
return(FALSE)
}
# snake head
head<-function(){
e$lastx<-e$head[1]
e$lasty<-e$head[2]
# 方向操作
if(e$dir=='up') e$head[2]<-e$head[2]+1
if(e$dir=='down') e$head[2]<-e$head[2]-1
if(e$dir=='left') e$head[1]<-e$head[1]-1
if(e$dir=='right') e$head[1]<-e$head[1]+1
}
# snake body
body<-function(){
e$m[e$lastx,e$lasty]<-0
e$m[e$bla_lastx, e$bla_lasty]<-0
e$m[e$bla[1],e$bla[2]]<-e$col_bla
e$m[e$head[1],e$head[2]]<-e$col_head
print(data.frame(x=e$lastx,y=e$lasty))
if(e$eat_num == 3){ # 连续吃三次果子
e$tail<-rbind(e$tail,data.frame(x=e$lastx,y=e$lasty))  # 矩阵合并,增加节数
e$eat_num<-0  # 重置吃果子数
}
if(length(index(e$col_furit))<=0){ #不存在水果
e$tail<-rbind(e$tail,data.frame(x=e$lastx,y=e$lasty))  # 矩阵合并
beep(5)  # 播放声音
e$eat_num<-e$eat_num+1
}
if(nrow(e$tail)>0) { #如果有尾巴
e$tail<-rbind(e$tail,data.frame(x=e$lastx,y=e$lasty))
e$m[e$tail[1,]$x,e$tail[1,]$y]<-e$col_path
e$tail<-e$tail[-1,]
e$m[e$lastx,e$lasty]<-e$col_tail
}
print(paste("snake idx",index(e$col_head)))
print(paste("snake axis:",e$head[1],e$head[2]))
}
# 画布背景
drawTable<-function(){
plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
}
# 根据矩阵画数据
drawMatrix<-function(){
idx<-which(e$m>0)
px<- (ifelse(idx%%e$width==0,e$width,idx%%e$width)-1)/e$width+e$step/2
py<- (ceiling(idx/e$height)-1)/e$height+e$step/2
pxy<-data.frame(x=px,y=py,col=e$m[idx])
points(pxy$x,pxy$y,col=pxy$col,pch=15,cex=4.4)
text(0.5,0.8,label=paste("你的得分",nrow(e$tail)),cex=2,col=2)
# 添加得分，使得分在画面中实时显示
}
furit()
bla()
head()
if(!fail()){
body()
drawTable()
drawMatrix()
}
}
# 开机画图
stage0<-function(){
e$stage<-0
plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
text(0.5,0.7,label="Snake Game",cex=5)
text(0.5,0.4,label="Any keyboard to start",cex=2,col=4)
text(0.5,0.3,label="Up,Down,Left,Rigth to control direction",cex=2,col=2)
text(0.2,0.05,label="Author:DanZhang",cex=1)
text(0.5,0.05,label="http://blog.fens.me",cex=1)
text(0.5,0.1,label="cai-3198911509",cex=1)
}
# 结束画图
stage2<-function(){
e$stage<-2
plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
text(0.5,0.7,label="Game Over",cex=5)
text(0.5,0.4,label="Space to restart, q to quit.",cex=2,col=4)
text(0.5,0.3,label=paste("Congratulations! You have eat",nrow(e$tail),"fruits!"),cex=2,col=2)
text(0.2,0.05,label="Author:DanZhang",cex=1)
text(0.5,0.05,label="http://blog.fens.me",cex=1)
text(0.5,0.1,label="cai-3198911509",cex=1)
}
# 暂停画面
stage3<-function() {
e$stage<-3
plot(0,0,xlim=c(0,1),ylim=c(0,1),type='n',xaxs="i", yaxs="i")
text(0.5,0.7,label="已暂停",cex=5)
text(0.5,0.4,label="按q退出，按p继续",cex=2,col=4)
text(0.5,0.3,label=paste("Congratulations! You have eat",nrow(e$tail),"fruits!"),cex=2,col=2)
text(0.2,0.05,label="Author:DanZhang",cex=1)
text(0.5,0.05,label="http://blog.fens.me",cex=1)
text(0.5,0.1,label="cai-3198911509",cex=1)
}
# 键盘事件
keydown<-function(K){
print(paste("keydown:",K,",stage:",e$stage));
if(e$stage==3) {
if(K == "q"){
stage2()  # 按下q键结束
}
if(K == "p"){
stage1()  # 按下p继续游戏
}
return(NULL)
}
if(e$stage==0){ # 开机画面
init()
stage1()
return(NULL)
}
if(e$stage==2){ # 结束画面
if(K=="q") q()
else if(K==' ') stage0()
return(NULL)
}
if(e$stage==1){ # 在游戏进行中
if(K == "q") {
stage2() # 如果按下q键就会结束
}
if (K == "p") {
stage3()  # 如果按下p，则进入暂停画面
} else {
if(tolower(K) %in% c("up","down","left","right")){
e$lastd<-e$dir
e$dir<-tolower(K)
stage1()
}
}
}
return(NULL)
}
#######################################
# RUN
#######################################
run<-function(){
X11()
par(mai=rep(0,4),oma=rep(0,4))
e<<-new.env()
stage0()
# 注册事件
getGraphicsEvent(prompt="Snake Game",onKeybd=keydown)
}
X11()
run()
}
devtools::load_all()
setwd("~/Documents/Snake1.1")
usethis::use_r("Snake_run")
devtools::load_all()
Snake_run()
devtools::check()
document()
library(devtools)
document()
?Snake_run
library(beepr)  # 导入包
